{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Rigatoni is the first server library to implement the NOODLES messaging protocol in Python. The NOOODLES protocol allows multiple client applications to interact collaboratively with data in real-time. The protocol is especially  geared towards applications that can render 3D meshes and other data. This server library provides objects and methods for maintaining a noodles session in state. The server uses a websocket connection to send CBOR encoded messages. To customize its implementation, the library  provides convenient interface methods to assist the user in writing their own methods for the server. The user can also add custom delegates to add additional functionality to any of the standard components.</p>  video  Rigatoni's Geometry Server used with Orzo for 3d visualizations"},{"location":"#why-use-rigatoni","title":"Why use Rigatoni?","text":"<p>Rigatoni is a great choice for anyone who wants to use the NOODLES protocol while working in Python. With a server application to host data and custom methods, users will be able to interact with data from any client application that implements the NOODLES protocol. Rigatoni offers a simple interface for creating methods and components, and it provides additional support for working with meshes and complex geometry. If you are looking to use NOODLES with a different language, there is currently support for C++, Rust, Julia, and Javascript  here, and if you are looking to build a client application in  Python, check out Rigatoni.</p>"},{"location":"#how-does-the-server-work","title":"How does the server work?","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Method\n    participant Server\n    participant Client\n    User-&gt;&gt;Method: Defines Methods and Components\n    User-&gt;&gt;Server: Starts Server with Starting State\n    Client-&gt;&gt;Server: Sends Intro Message\n    Server-&gt;&gt;Client: Updates the Client with Current State\n    loop until end of session\n        Client-&gt;&gt;Server: Request to Invoke Method\n        Server-&gt;&gt;Method: Invokes Method\n        Method-&gt;&gt;Server: Invokes Signals, Creates, Updates, and Deletes Components\n        Server-&gt;&gt;Client: Broadcasts Component Changes to All Clients\n        Server-&gt;&gt;Client: Sends Method Reply with Response or Exception\n    end</code></pre> <p>The server handles incoming websocket connections and maintains a list of clients that are currently connected.  After a client has sent an introductory message, they are free to invoke methods defined by the server. The server  parses each message and attempts to invoke a corresponding method which has been injected by the user. The server  calls this method and sends a reply with either a response or an exception.</p>"},{"location":"basic_usage/","title":"Basic usage","text":"<ol> <li>Define starting state</li> <li>Set up delegates</li> <li>Run the server</li> </ol>"},{"location":"basic_usage/#starting-state","title":"Starting State","text":"<p>You can use starting component objects to help define the starting state</p> <pre><code>rigatoni.StartingComponent(Type[Component], dict[Component_Attr, Value])\n</code></pre> <ul> <li>You can refer to the objects listed here to find all the available delegates along with their  mandatory, default, and optional attributes. Additional information on NOODLE components and their attributes can  be found here</li> <li>When creating methods, an additional callable object should be attached. This method will be injected onto the  server, and it will be associated with its corresponding method component.</li> </ul> <pre><code>rigatoni.StartingComponent(Type[Component], dict[Component_Attr, Value], Callable)\n</code></pre>"},{"location":"basic_usage/#defining-methods","title":"Defining Methods","text":"<p>To help with creating methods that manipulate the server's state, Rigatoni provides several methods that can be used manage objects in the scene. More information on these methods can be found in the server section of the API reference tab. Also, it is important to note that since each method is injected onto the server, they are called with a couple of  arguments by default. The first two arguments to each method should always be the server object itself and  a context. This provides easy access to essential information that can be used in the method. Exceptions raised in these methods should be MethodException objects. These exceptions  will be caught by the server and sent to clients in a method reply message.</p>"},{"location":"basic_usage/#delegates","title":"Delegates","text":"<p>The server comes with a default delegate class for each component that is maintained in the server's state. These default delegates can be subclassed to add more functionality to each component in the scene. For example, the table  delegate doesn't store any data by default, but users can customize it using any data structure they like. Below is a simple example where the table delegate uses an added dataframe. A more complete version of this example can be found in here.</p> <p>Note</p> <p>In this library, delegates are Pydantic models. This means that they come with some built in functionality, and it might be helpful to read the Pydantic docs to learn more about how to use them.</p> <pre><code>import pandas as pd\nfrom rigatoni import Table\n\nclass CustomTableDelegate(Table):\n\n    dataframe = pd.DataFrame()\n\n    def handle_delete(self, keys: list[int]):\n        self.dataframe.drop(index=keys, inplace=True)\n        return keys\n</code></pre>"},{"location":"basic_usage/#logging","title":"Logging","text":"<p>Rigatoni uses the standard logging module for Python. The logging level can be set by the user to any of the following:</p> <ul> <li><code>logging.DEBUG</code></li> <li><code>logging.INFO</code></li> <li><code>logging.WARNING</code></li> <li><code>logging.ERROR</code></li> <li><code>logging.CRITICAL</code></li> </ul> <p>Here is a snippet you can use to toggle the logging level: <pre><code>import logging\n\nlogging.basicConfig(\n    format=\"%(message)s\",\n    level=logging.DEBUG\n)\n</code></pre></p>"},{"location":"basic_usage/#run-the-server","title":"Run the Server","text":"<p>You can run the server indefinitely by calling <code>server.run()</code>. This will run until <code>server.shutdown()</code> is called.</p> <p><pre><code>server = Server(50000, starting_state, delegates)\nserver.run() \n</code></pre> or alternatively, you can use a context manager to automatically start running the server in a new thread</p> <pre><code>with Server(50000, starting_state, delegates) as server:\n    # do stuff\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Any help with the project would be super appreciated. Here are some steps to get started.</p> <ol> <li>Clone the repo</li> <li>Install the dependencies    <pre><code>pip install -r requirements.txt\npip install -r tests/requirements.txt\n</code></pre></li> <li>Switch to the <code>develop</code> branch or create a new one</li> <li>Make your changes</li> <li>To update the documentation, simply edit the docstrings for each method.</li> <li>Run the tests<ul> <li>These flags will help show which lines are missing test coverage    <pre><code> pytest --cov rigatoni --cov-report term-missing\n</code></pre></li> </ul> </li> <li>Submit a pull request<ul> <li>There are github actions set up to run the tests and build the docs for each pull request.</li> </ul> </li> </ol>"},{"location":"install/","title":"Install","text":"<p>Installation is as simple as:</p> <pre><code>pip install rigatoni\n</code></pre> <p>Rigatoni has a few dependencies:</p> <ul> <li><code>websockets</code>: Websocket connections in Python.</li> <li><code>cbor2</code>: Concise Binary Object Representation for messages.</li> <li><code>pydantic</code>: Data validation and coercion for parsing messages.</li> </ul> <p>If you've got Python 3.9+ and <code>pip</code> installed, you're good to go.</p>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>Pydantic has the following optional dependencies:</p> <ul> <li>If you require support for meshes and geometry object creation, you can add  numpy and meshio </li> </ul> <p>To install optional dependencies along with Rigatoni:</p> <pre><code>pip install rigatoni[geometry]\n</code></pre> <p>Note</p> <p>For stability, Rigatoni's core dependencies are pinned to specific versions. While these are up to date as of August 2023, you may want to update them to the latest versions. To do so, simply update the package yourself.</p>"},{"location":"noodles/","title":"What is NOODLES?","text":"<p>NOODLES is a messaging protocol for interactive visualizations. Client and server libraries can implement the protocol to allow for real-time collaboration across visually rich applications.</p> <p>As an intern with little experience in the field of data visualiation and computer graphics, I struggled at first to understand what exactly NOODLES is about and what it aims to accomplish. This document aims to help explain the project to newcomers with all that I have learned while working on Penne, Rigatoni, and Orzo.</p> <p>NOODLES is at its core is a messaging protocol. This is simply an agreement between client and server applications, so  they can communicate in a standardized way. The ultimate goal is to allow for real-time collaboration across different devices or client applications. For example, researchers could all be working on the same data set at the same time  while visualizing it from a web browser, a VR headset, or a command line interface. Researchers no longer would have to set up their data in a specific way to work with a particular visualization tool. Instead, they could use NOODLES to connect their data to any tool that implements the protocol. The NOODLES protocol would be the  bridge between these different tools and devices.</p> <p>While NOODLES specifically refers to the protocol that defines the types of messages that can be sent, this project includes client and server libraries that implement the protocol in a specific language. That way, users can use the  protocol in their language of choice. As of writing this, there is support for python, rust, c++, javascript, and julia.</p>"},{"location":"noodles/#breaking-down-a-noodles-session","title":"Breaking down a NOODLES session","text":"<p>A NOODLES session is composed of a server and one or more clients. A server hosts data and handles requests from clients to manipulate that data. Clients connect to the server with an introductory message and can request data from the server or send messages to the server to invoke methods that manipulate the data. The server then sends updates to all connected clients to keep them in sync.</p>"},{"location":"noodles/#objects-in-a-session","title":"Objects in a Session","text":"<p>If you look at the message specification, you'll notice that the messages follow a pattern. In general, most messages signal the creation, deletion, or modification of an object. These objects include lights, geometries, buffers, and more. These objects are all used to compose a scene that can be  rendered in 3d. Below is a diagram that shows the basic layout of the scene graph. For information on each type of  object, check out the latter half of this page.</p> <p></p>"},{"location":"noodles/#methods-and-signals","title":"Methods and Signals","text":"<p>The server defines methods that can be invoked by clients to manipulate the data. For the client this is like getting a menu at a restaurant. If the client invokes a method to say add a point to a data table, the server will process that  message then send a signal to all connected clients to let them know that the data has been updated. The server will also send a reply to let the client know whether the method invocation went through alright.</p>"},{"location":"noodles/#a-spheres-journey","title":"A sphere's journey","text":"<p>To get an idea of how all of these pieces come together to get something 3d to show up on a screen, I figured it would be helpful to walk through an example. Consider the humble sphere...</p> <p></p> <p>First a server application will define some methods that create the sphere, or maybe it will already be present in the server's starting state. This is a problem for the server application which would use the support of a server  library to make this happen. The client connects to the server's websocket address with an intro message, and the server sends back a series of messages to catch the client up to the server's current state. In this example, that would include an entity create message for the general entity that would hold the sphere. Entities are essentially containers that  house lights, geometry, and plots while storing important position information. There would also be a geometry creation message for the sphere geometry / mesh. There would also be buffer create messages for the binary data that makes up this geometry. The buffers could store positions, colors, normals, instances, and more essential information that allow the client to render the sphere. Buffer views let you know how to interpret this binary data. There could possibly be materials and textures messages that would allow the client to render the sphere with unique colors and texture. If there was a texture, you can think of it as a sort of wrapping paper that gets applied to the sphere. An image creation message would be sent to tell the client what this wrapping paper looks like,  and a sampler would let the client know how to apply the wrapping paper to the sphere.  With all of these pieces the client has everything it needs to render the sphere, and we have used most objects in the  scene graph diagram above.</p> <p>While this is pretty surface level, I hope it gives you a rough idea of how the pieces of the protocol fits together. If you want to learn more about how the client would use these pieces to render the sphere, check out Orzo's documentation.</p>"},{"location":"noodles/#more-info","title":"More Info","text":"<ul> <li>Full Message Specification</li> <li>More Client and Server Libraries</li> </ul>"},{"location":"quick_start/","title":"Quick start","text":"<p>Here's a basic example to get a plain server running with largely default components. The server will be initialized  with one method to begin with, and the server will use the custom table delegate for each table in the scene.  For more detailed examples, check out this repo.</p> <pre><code>import rigatoni as rig\n\nclass CustomTable(rig.Table):\n\n    extra_info = None\n\n    def handle_clear(self):\n        print(\"Clearing table\")\n\ndef basic_method(server, context):\n    print(\"Hello World!\")\n\nstarting_state = [\n    rig.StartingComponent(rig.Method, {\"name\": \"basic_method\", \"arg_doc\": []}, basic_method),\n]\n\ndelegates = {\n    rig.Table: CustomTable\n}\n\nwith rig.Server(50000, starting_state) as server:\n    # do stuff\n    pass\n</code></pre>"},{"location":"api_reference/delegates/","title":"Delegates","text":""},{"location":"api_reference/delegates/#rigatoni.Delegate","title":"rigatoni.Delegate","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Parent class for all delegates</p> <p>Defines general methods that should be available for all delegates. In this context, a delegate refers to an object in a NOODLES scene that can be subclassed and extended by the user. For example, a user can create an implementation for a table that specifically suits their needs. The server's job is essentially to manage the state of all delegates, and to call the appropriate methods on them when necessary. Most methods defined by the user will also be to manipulate the state of the delegates.</p> <p>Attributes:</p> Name Type Description <code>server</code> <code>Server</code> <p>server delegate is attached to</p> <code>id</code> <code>ID</code> <p>(ID): Unique identifier for delegate</p> <code>name</code> <code>Optional[str]</code> <p>Name of delegate</p> <code>signals</code> <code>Optional[dict]</code> <p>Signals that can be called on delegate, method name to callable</p>"},{"location":"api_reference/delegates/#rigatoni.Method","title":"rigatoni.Method","text":"<p>             Bases: <code>Delegate</code></p> <p>A method that clients can request the server to call.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>MethodID</code> <p>ID for the method</p> <code>name</code> <code>str</code> <p>Name of the method</p> <code>doc</code> <code>Optional[str]</code> <p>Documentation for the method</p> <code>return_doc</code> <code>Optional[str]</code> <p>Documentation for the return value</p> <code>arg_doc</code> <code>List[MethodArg]</code> <p>Documentation for the arguments</p>"},{"location":"api_reference/delegates/#rigatoni.Signal","title":"rigatoni.Signal","text":"<p>             Bases: <code>Delegate</code></p> <p>A signal that the server can send to update clients.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>SignalID</code> <p>ID for the signal</p> <code>name</code> <code>str</code> <p>Name of the signal</p> <code>doc</code> <code>Optional[str]</code> <p>Documentation for the signal</p> <code>arg_doc</code> <code>List[MethodArg]</code> <p>Documentation for the arguments</p>"},{"location":"api_reference/delegates/#rigatoni.Entity","title":"rigatoni.Entity","text":"<p>             Bases: <code>Delegate</code></p> <p>A generic container</p> <p>Can reference other entities, geometry, plots, and lights. It can be rendered, if it has a render rep. It may have associated methods and signals. The transform is relative to the parent entity. In other contexts it may be called a node.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>EntityID</code> <p>ID for the entity</p> <code>name</code> <code>Optional[str]</code> <p>Name of the entity</p> <code>parent</code> <code>Optional[EntityID]</code> <p>Parent entity</p> <code>transform</code> <code>Optional[Mat4]</code> <p>Local transform for the entity, ie. positional information</p> <code>text_rep</code> <code>Optional[TextRepresentation]</code> <p>Text representation for the entity</p> <code>web_rep</code> <code>Optional[WebRepresentation]</code> <p>Web representation for the entity</p> <code>render_rep</code> <code>Optional[RenderRepresentation]</code> <p>Render representation for the entity, points to geometry and instances</p> <code>lights</code> <code>Optional[List[LightID]]</code> <p>List of lights attached to the entity</p> <code>tables</code> <code>Optional[List[TableID]]</code> <p>List of tables attached to the entity</p> <code>plots</code> <code>Optional[List[PlotID]]</code> <p>List of plots attached to the entity</p> <code>tags</code> <code>Optional[List[str]]</code> <p>List of tags for the entity</p> <code>methods_list</code> <code>Optional[List[MethodID]]</code> <p>List of methods attached to the entity</p> <code>signals_list</code> <code>Optional[List[SignalID]]</code> <p>List of signals attached to the entity</p> <code>influence</code> <code>Optional[BoundingBox]</code> <p>Bounding box for the entity</p>"},{"location":"api_reference/delegates/#rigatoni.Plot","title":"rigatoni.Plot","text":"<p>             Bases: <code>Delegate</code></p> <p>An abstract plot object.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>PlotID</code> <p>ID for the plot</p> <code>name</code> <code>Optional[str]</code> <p>Name of the plot</p> <code>table</code> <code>Optional[TableID]</code> <p>Table to plot</p> <code>simple_plot</code> <code>Optional[str]</code> <p>Simple plot to render</p> <code>url_plot</code> <code>Optional[str]</code> <p>URL for plot to render</p> <code>methods_list</code> <code>Optional[List[MethodID]]</code> <p>List of methods attached to the plot</p> <code>signals_list</code> <code>Optional[List[SignalID]]</code> <p>List of signals attached to the plot</p>"},{"location":"api_reference/delegates/#rigatoni.Buffer","title":"rigatoni.Buffer","text":"<p>             Bases: <code>Delegate</code></p> <p>A buffer of bytes containing data for an image or a mesh.</p> <p>Bytes can be stored directly in the buffer with inline_bytes, or they can be stored in a URI with uri_bytes. The server should create a separate server to host the bytes, and there is support for this in the ByteServer class. To obtain these bytes, clients would have to make an HTTP request to the URI.</p> <p>A buffer could store a single attribute, or it could store multiple attributes interleaved together. This is where buffer views specify how to interpret the buffer.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>BufferID</code> <p>ID for the buffer</p> <code>name</code> <code>Optional[str]</code> <p>Name of the buffer</p> <code>size</code> <code>int</code> <p>Size of the buffer in bytes</p> <code>inline_bytes</code> <code>Optional[bytes]</code> <p>Bytes of the buffer</p> <code>uri_bytes</code> <code>Optional[str]</code> <p>URI for the bytes</p>"},{"location":"api_reference/delegates/#rigatoni.BufferView","title":"rigatoni.BufferView","text":"<p>             Bases: <code>Delegate</code></p> <p>A view into a buffer, specifying a subset of the buffer and how to interpret it.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>BufferViewID</code> <p>ID for the buffer view</p> <code>name</code> <code>Optional[str]</code> <p>Name of the buffer view</p> <code>source_buffer</code> <code>BufferID</code> <p>Buffer that the view is referring to</p> <code>type</code> <code>BufferType</code> <p>Type of the buffer view</p> <code>offset</code> <code>int</code> <p>Offset into the buffer in bytes</p> <code>length</code> <code>int</code> <p>Length of the buffer view in bytes</p>"},{"location":"api_reference/delegates/#rigatoni.Material","title":"rigatoni.Material","text":"<p>             Bases: <code>Delegate</code></p> <p>A material that can be applied to a mesh.</p> <p>The material is a collection of textures and factors that are used to render the mesh.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>MaterialID</code> <p>ID for the material</p> <code>name</code> <code>Optional[str]</code> <p>Name of the material</p> <code>pbr_info</code> <code>Optional[PBRInfo]</code> <p>Information for physically based rendering</p> <code>normal_texture</code> <code>Optional[TextureRef]</code> <p>Texture for normals</p> <code>occlusion_texture</code> <code>Optional[TextureRef]</code> <p>Texture for occlusion</p> <code>occlusion_texture_factor</code> <code>Optional[float]</code> <p>Factor for occlusion</p> <code>emissive_texture</code> <code>Optional[TextureRef]</code> <p>Texture for emissive</p> <code>emissive_factor</code> <code>Optional[Vec3]</code> <p>Factor for emissive</p> <code>use_alpha</code> <code>Optional[bool]</code> <p>Whether to use alpha</p> <code>alpha_cutoff</code> <code>Optional[float]</code> <p>Alpha cutoff</p> <code>double_sided</code> <code>Optional[bool]</code> <p>Whether the material is double-sided</p>"},{"location":"api_reference/delegates/#rigatoni.Image","title":"rigatoni.Image","text":"<p>             Bases: <code>Delegate</code></p> <p>An image, can be used for a texture</p> <p>Like a buffer, an image can be stored in a URI to reduce the size of messages. To obtain the bytes, you would have to make an HTTP request to the URI.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>ImageID</code> <p>ID for the image</p> <code>name</code> <code>Optional[str]</code> <p>Name of the image</p> <code>buffer_source</code> <code>Optional[BufferID]</code> <p>Buffer that the image is stored in</p> <code>uri_source</code> <code>Optional[str]</code> <p>URI for the bytes if they are hosted externally</p>"},{"location":"api_reference/delegates/#rigatoni.Texture","title":"rigatoni.Texture","text":"<p>             Bases: <code>Delegate</code></p> <p>A texture, can be used for a material</p> <p>This is like a wrapping paper that is applied to a mesh. The image specifies the pattern, and the sampler specifies which part of the image should be applied to each part of the mesh.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TextureID</code> <p>ID for the texture</p> <code>name</code> <code>Optional[str]</code> <p>Name of the texture</p> <code>image</code> <code>ImageID</code> <p>Image to use for the texture</p> <code>sampler</code> <code>Optional[SamplerID]</code> <p>Sampler to use for the texture</p>"},{"location":"api_reference/delegates/#rigatoni.Sampler","title":"rigatoni.Sampler","text":"<p>             Bases: <code>Delegate</code></p> <p>A sampler to use for a texture</p> <p>A sampler specifies how to take portions of an image and apply them to a mesh.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>SamplerID</code> <p>ID for the sampler</p> <code>name</code> <code>Optional[str]</code> <p>Name of the sampler</p> <code>mag_filter</code> <code>Optional[MagFilterTypes]</code> <p>Magnification filter</p> <code>min_filter</code> <code>Optional[MinFilterTypes]</code> <p>Minification filter</p> <code>wrap_s</code> <code>Optional[SamplerMode]</code> <p>Wrap mode for S</p> <code>wrap_t</code> <code>Optional[SamplerMode]</code> <p>Wrap mode for T</p>"},{"location":"api_reference/delegates/#rigatoni.Light","title":"rigatoni.Light","text":"<p>             Bases: <code>Delegate</code></p> <p>Represents a light in the scene</p> <p>For these purposes, a light is just a couple of properties like color, intensity, and light type. The entity that stores the light will dictate position and direction with its transform. The client application is then responsible for using this information to render the light. The light is either a point light, a spotlight, or a directional light.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>LightID</code> <p>ID for the light</p> <code>name</code> <code>Optional[str]</code> <p>Name of the light</p> <code>color</code> <code>Optional[RGB]</code> <p>Color of the light</p> <code>intensity</code> <code>Optional[float]</code> <p>Intensity of the light</p> <code>point</code> <code>Optional[PointLight]</code> <p>Point light information</p> <code>spot</code> <code>Optional[SpotLight]</code> <p>Spotlight information</p> <code>directional</code> <code>Optional[DirectionalLight]</code> <p>Directional light information</p>"},{"location":"api_reference/delegates/#rigatoni.Geometry","title":"rigatoni.Geometry","text":"<p>             Bases: <code>Delegate</code></p> <p>Represents geometry in the scene and can be used for meshes</p> <p>This is more of a collection of patches, but each patch will contain the geometry information to render a mesh. The patch references buffer views and buffers for each attribute, and a material to use for rendering. Instances are stored in a separate buffer that is referenced at the entity level.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>GeometryID</code> <p>ID for the geometry</p> <code>name</code> <code>Optional[str]</code> <p>Name of the geometry</p> <code>patches</code> <code>List[GeometryPatch]</code> <p>Patches that make up the geometry</p>"},{"location":"api_reference/delegates/#rigatoni.Table","title":"rigatoni.Table","text":"<p>             Bases: <code>Delegate</code></p> <p>Data table</p> <p>Note that this delegate doesn't store any actual data. Delegates are meant to subclass and add functionality to this class. For the client to receive the actual data, they must subscribe to the table. The client will have access to certain injected methods that allow them to insert, update, delete, and clear the table. This class provides some abstract methods that can be overridden to handle these events.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TableID</code> <p>ID for the table</p> <code>name</code> <code>Optional[str]</code> <p>Name of the table</p> <code>meta</code> <code>Optional[str]</code> <p>Metadata for the table</p> <code>methods_list</code> <code>Optional[List[MethodID]]</code> <p>List of methods for the table</p> <code>signals_list</code> <code>Optional[List[SignalID]]</code> <p>List of signals for the table</p>"},{"location":"api_reference/delegates/#rigatoni.Table.handle_clear","title":"handle_clear","text":"<pre><code>handle_clear()\n</code></pre> <p>Method to handle clearing the table</p> Source code in <code>rigatoni/noodle_objects.py</code> <pre><code>def handle_clear(self):\n\"\"\"Method to handle clearing the table\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/delegates/#rigatoni.Table.handle_delete","title":"handle_delete","text":"<pre><code>handle_delete(keys)\n</code></pre> <p>Method to handle deleting from the table</p> Source code in <code>rigatoni/noodle_objects.py</code> <pre><code>def handle_delete(self, keys: List[int]):\n\"\"\"Method to handle deleting from the table\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/delegates/#rigatoni.Table.handle_insert","title":"handle_insert","text":"<pre><code>handle_insert(new_rows)\n</code></pre> <p>Method to handle inserting into the table</p> Source code in <code>rigatoni/noodle_objects.py</code> <pre><code>def handle_insert(self, new_rows: List[List[int]]):\n\"\"\"Method to handle inserting into the table\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/delegates/#rigatoni.Table.handle_set_selection","title":"handle_set_selection","text":"<pre><code>handle_set_selection(selection)\n</code></pre> <p>Method to handle setting a selection</p> Source code in <code>rigatoni/noodle_objects.py</code> <pre><code>def handle_set_selection(self, selection: Selection):\n\"\"\"Method to handle setting a selection\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/delegates/#rigatoni.Table.handle_update","title":"handle_update","text":"<pre><code>handle_update(keys, rows)\n</code></pre> <p>Method to handle updating the table</p> Source code in <code>rigatoni/noodle_objects.py</code> <pre><code>def handle_update(self, keys: List[int], rows: List[List[int]]):\n\"\"\"Method to handle updating the table\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/delegates/#rigatoni.Table.table_reset","title":"table_reset","text":"<pre><code>table_reset(tbl_init)\n</code></pre> <p>Invoke table reset signal</p> Source code in <code>rigatoni/noodle_objects.py</code> <pre><code>def table_reset(self, tbl_init: TableInitData):\n\"\"\"Invoke table reset signal\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/delegates/#rigatoni.Table.table_rows_removed","title":"table_rows_removed","text":"<pre><code>table_rows_removed(keys)\n</code></pre> <p>Invoke table rows removed signal</p> Source code in <code>rigatoni/noodle_objects.py</code> <pre><code>def table_rows_removed(self, keys: List[int]):\n\"\"\"Invoke table rows removed signal\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/delegates/#rigatoni.Table.table_selection_updated","title":"table_selection_updated","text":"<pre><code>table_selection_updated(selection)\n</code></pre> <p>Invoke table selection updated signal</p> Source code in <code>rigatoni/noodle_objects.py</code> <pre><code>def table_selection_updated(self, selection: Selection):\n\"\"\"Invoke table selection updated signal\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/delegates/#rigatoni.Table.table_updated","title":"table_updated","text":"<pre><code>table_updated(keys, rows)\n</code></pre> <p>Invoke table updated signal</p> Source code in <code>rigatoni/noodle_objects.py</code> <pre><code>def table_updated(self, keys: List[int], rows: List[List[int]]):\n\"\"\"Invoke table updated signal\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/delegates/#rigatoni.StartingComponent","title":"rigatoni.StartingComponent","text":"<pre><code>StartingComponent(kind, component_attrs, method=None, document=False)\n</code></pre> <p>             Bases: <code>object</code></p> <p>User input object for setting starting components on server</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Type[Delegate]</code> <p>Type of component</p> <code>component_attrs</code> <code>dict</code> <p>Attributes for component</p> <code>method</code> <code>Callable</code> <p>Optional method to call on component</p> <code>document</code> <code>bool</code> <p>Whether method / signal is attached to and can be called on document</p> Source code in <code>rigatoni/noodle_objects.py</code> <pre><code>def __init__(self, kind, component_attrs: Dict[str, Any], method: Optional[Callable] = None, document: bool = False):\n    self.type = kind\n    self.component_attrs = component_attrs\n    self.method = method\n    self.document = document\n</code></pre>"},{"location":"api_reference/delegates/#rigatoni.MethodException","title":"rigatoni.MethodException","text":"<pre><code>MethodException(code, message=None, data=None)\n</code></pre> <p>             Bases: <code>Exception</code></p> <p>Custom exception specifically for methods defined on the server</p> <p>User defined methods injected on the server should raise this exception, and it will be sent to clients in a method reply message. Exception codes are defined in the table below.</p> Code Message Description -32700 Parse Error Given invocation object is malformed and failed to be validated -32600 Invalid Request Given invocation object does not fulfill required semantics -32601 Method Not Found Given invocation object tries to call a method that does not exist -32602 Invalid Parameters Given invocation tries to call a method with invalid parameters -32603 Internal Error The invocation fulfills all requirements, but an internal error prevents the server from executing it <p>Attributes:</p> Name Type Description <code>code</code> <code>int</code> <p>Code for the exception</p> <code>message</code> <code>Optional[message]</code> <p>Message for the exception</p> <code>data</code> <code>Optional[data]</code> <p>Data for the exception</p> Source code in <code>rigatoni/noodle_objects.py</code> <pre><code>def __init__(self, code: int, message: Optional[str] = None, data: Optional[Any] = None):\n    self.code = code\n    self.message = message\n    self.data = data\n</code></pre>"},{"location":"api_reference/geometry/","title":"Geometry","text":""},{"location":"api_reference/geometry/#rigatoni.ByteServer","title":"rigatoni.ByteServer","text":"<pre><code>ByteServer(port=8000)\n</code></pre> <p>             Bases: <code>object</code></p> <p>Server to Host URI Bytes.</p> <p>This is helpful for large meshes and images that would otherwise be too large to send using CBOR and the websocket connection. The server maps a tag to a buffer, and the client can request the buffer using the url that includes the tag.</p> <p>Note</p> <p>The server is start up automatically in a new thread when the class is instantiated, and <code>shutdown</code> must be called to clean up this thread.</p> <p>Attributes:</p> Name Type Description <code>host</code> <code>str</code> <p>IP address for server</p> <code>port</code> <code>int</code> <p>port server is listening on</p> <code>socket</code> <code>socket</code> <p>socket connection </p> <code>buffers</code> <code>dict</code> <p>mapping tag to buffer</p> <code>_next_tag</code> <code>int</code> <p>next available tag for a buffer</p> <code>url</code> <code>str</code> <p>base url to reach server without tag</p> <code>thread</code> <code>Thread</code> <p>background thread server is running in</p> <code>running</code> <code>bool</code> <p>flag indicating whether server is running</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>port to listen and host on</p> <code>8000</code> Source code in <code>rigatoni/byte_server.py</code> <pre><code>def __init__(self, port: int = 8000):\n\"\"\"Constructor to create the server\n\n    Args:\n        port (int): port to listen and host on\n    \"\"\"\n\n    name = socket.gethostname()\n    try:  # supposed to work without .local, but had to add to match system preferences - sharing\n        self.host = socket.gethostbyname(name)\n    except socket.gaierror:\n        self.host = socket.gethostbyname(f\"{name}.local\")\n\n    self.port = port\n    self.socket = None\n    self.buffers = {}\n    self._next_tag = 0\n    self.url = f\"http://{self.host}:{port}\"\n\n    self.thread = threading.Thread(target=self._run, args=())\n    self.running = True\n    self.ready = threading.Event()\n    self.thread.start()\n    self.ready.wait()\n</code></pre>"},{"location":"api_reference/geometry/#rigatoni.ByteServer.add_buffer","title":"add_buffer","text":"<pre><code>add_buffer(buffer)\n</code></pre> <p>Add buffer to server and return url to reach it</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>bytes</code> <p>bytes to add as buffer</p> required Source code in <code>rigatoni/byte_server.py</code> <pre><code>def add_buffer(self, buffer) -&gt; str:\n\"\"\"Add buffer to server and return url to reach it\n\n    Args:\n        buffer (bytes): bytes to add as buffer\n    \"\"\"\n\n    tag = self._get_tag()\n    self.buffers[tag] = buffer\n    url = f\"{self.url}/{tag}\"\n    logging.info(f\"Adding buffer to byte server: {url}\")\n\n    return url\n</code></pre>"},{"location":"api_reference/geometry/#rigatoni.ByteServer.get_buffer","title":"get_buffer","text":"<pre><code>get_buffer(uri)\n</code></pre> <p>Helper to get bytes for a URI</p> <p>Mostly used in geometry creation for exporting as of right now</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>uri for bytes</p> required Source code in <code>rigatoni/byte_server.py</code> <pre><code>def get_buffer(self, uri: str):\n\"\"\"Helper to get bytes for a URI\n\n    Mostly used in geometry creation for exporting as of right now\n\n    Args:\n        uri (str): uri for bytes\n    \"\"\"\n\n    m = re.search(f'(?&lt;={self.port}/).+\\Z', uri)\n    if m:\n        tag = m.group(0)\n        buffer_bytes = self.buffers[tag]\n        return buffer_bytes\n    else:\n        raise ValueError(\"Invalid HTTP Request\")\n</code></pre>"},{"location":"api_reference/geometry/#rigatoni.ByteServer.shutdown","title":"shutdown","text":"<pre><code>shutdown()\n</code></pre> <p>Stop running thread</p> Source code in <code>rigatoni/byte_server.py</code> <pre><code>def shutdown(self):\n\"\"\"Stop running thread\"\"\"\n\n    self.running = False\n    self.thread.join()\n</code></pre>"},{"location":"api_reference/geometry/#rigatoni.geometry.methods","title":"rigatoni.geometry.methods","text":"<p>Helpful methods for assisting with the creation of geometry objects</p>"},{"location":"api_reference/geometry/#rigatoni.geometry.objects","title":"rigatoni.geometry.objects","text":"<p>Module with additional objects to help with geometry creation</p> <p>These are based on the noodle_objects.py module and implement validation</p>"},{"location":"api_reference/server/","title":"Server","text":""},{"location":"api_reference/server/#rigatoni.Server","title":"rigatoni.Server","text":"<pre><code>Server(port, starting_state, delegate_map=None, json_output=None)\n</code></pre> <p>             Bases: <code>object</code></p> <p>Overarching object for managing the state of a NOODLES session</p> <p>Handles communication and multiple client connections. The server provides several methods for interacting with and creating delegates. These are especially useful for defining custom methods that the server will expose to clients. Can be instatiated normally, or it can be used as a context manager to automatically start and stop the server while running in a new thread.</p> <p>Attributes:</p> Name Type Description <code>port</code> <code>int</code> <p>port server is running on</p> <code>clients</code> <code>set</code> <p>client connections</p> <code>ids</code> <code>dict</code> <p>maps object type to slot tracking info (next_slot, on_deck)</p> <code>state</code> <code>dict</code> <p>document's current state, contains all components with component ID as the key</p> <code>client_state</code> <code>dict</code> <p>lagging state to keep track of how up-to-date clients are</p> <code>references</code> <code>dict</code> <p>maps component ID to all the component ID's that reference it</p> <code>delete_queue</code> <code>set</code> <p>components that are referenced but have been requested to be deleted</p> <code>ready</code> <code>Event</code> <p>event to signal when server is ready to accept connections</p> <code>shutdown_event</code> <code>Event</code> <p>event to signal when server is shutting down</p> <code>thread</code> <code>Thread</code> <p>thread server is running on if using context manager</p> <code>byte_server</code> <code>ByteServer</code> <p>slot to store reference to server that serves uri bytes</p> <code>json_output</code> <code>str</code> <p>path to json file to output message logs</p> <code>custom_delegates</code> <code>dict</code> <p>maps component type to delegate class</p> <code>id_map</code> <code>dict</code> <p>maps component type to ID type</p> <code>id_decoder</code> <code>dict</code> <p>maps ID type to base component type, useful for getting base class from ID</p> <code>message_map</code> <code>dict</code> <p>maps action and type to message ID</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>port to run server on</p> required <code>starting_state</code> <code>list[StartingComponent]</code> <p>list of objects containing the info to create components on initialization</p> required <code>delegate_map</code> <code>dict</code> <p>maps noodles component type to instance of delegate class</p> <code>None</code> <code>json_output</code> <code>str</code> <p>path to json file to output message logs</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>invalid arguments to create starting component</p> <code>ValueError</code> <p>no method specified for method starting component</p> Source code in <code>rigatoni/core.py</code> <pre><code>def __init__(self, port: int, starting_state: list[StartingComponent],\n             delegate_map: dict[Type[Delegate], Type[Delegate]] = None, json_output: str = None):\n\"\"\"Constructor\n\n    Args:\n        port (int):\n            port to run server on\n        starting_state (list[StartingComponent]):\n            list of objects containing the info to create components on initialization\n        delegate_map (dict):\n            maps noodles component type to instance of delegate class\n        json_output (str):\n            path to json file to output message logs\n    Raises:\n        TypeError: invalid arguments to create starting component\n        ValueError: no method specified for method starting component\n    \"\"\"\n\n    self.port = port\n    self.clients = set()\n    self.ids = {}\n    self.state = {}\n    self.client_state = {}\n    self.references = {}\n    self.delete_queue = set()\n    self.ready = threading.Event()\n    self.shutdown_event = asyncio.Event()\n    self.thread = None\n    self.byte_server = None\n    self.json_output = json_output\n    if json_output:\n        with open(json_output, \"w\") as outfile:  # Clear out old contents\n            outfile.write(\"JSON Log\\n\")\n\n    # Set up id's and custom delegates\n    self.custom_delegates = delegate_map if delegate_map else {}\n    self.id_map = id_map.copy()\n    for old, new in self.custom_delegates.items():\n        self.id_map[new] = self.id_map.pop(old)\n    self.id_decoder = {val: key for key, val in id_map.items()}\n\n    self.message_map = {\n        (\"create\", MethodID): 0,\n        (\"delete\", MethodID): 1,\n        (\"create\", SignalID): 2,\n        (\"delete\", SignalID): 3,\n        (\"create\", EntityID): 4,\n        (\"update\", EntityID): 5,\n        (\"delete\", EntityID): 6,\n        (\"create\", PlotID): 7,\n        (\"update\", PlotID): 8,\n        (\"delete\", PlotID): 9,\n        (\"create\", BufferID): 10,\n        (\"delete\", BufferID): 11,\n        (\"create\", BufferViewID): 12,\n        (\"delete\", BufferViewID): 13,\n        (\"create\", MaterialID): 14,\n        (\"update\", MaterialID): 15,\n        (\"delete\", MaterialID): 16,\n        (\"create\", ImageID): 17,\n        (\"delete\", ImageID): 18,\n        (\"create\", TextureID): 19,\n        (\"delete\", TextureID): 20,\n        (\"create\", SamplerID): 21,\n        (\"delete\", SamplerID): 22,\n        (\"create\", LightID): 23,\n        (\"update\", LightID): 24,\n        (\"delete\", LightID): 25,\n        (\"create\", GeometryID): 26,\n        (\"delete\", GeometryID): 27,\n        (\"create\", TableID): 28,\n        (\"update\", TableID): 29,\n        (\"delete\", TableID): 30,\n        (\"update\", None): 31,\n        (\"reset\", None): 32,\n        (\"invoke\", None): 33,\n        (\"reply\", None): 34,\n        (\"initialized\", None): 35\n    }\n\n    # Set up starting state\n    self.state[\"document\"] = Document(server=self, id=ID(slot=0, gen=0))\n    self.client_state[\"document\"] = Document(server=self, id=ID(slot=0, gen=0))\n    for starting_component in starting_state:\n        comp_type = starting_component.type\n        comp_method = starting_component.method\n\n        try:\n            comp = self.create_component(comp_type, **starting_component.component_attrs)\n        except Exception as e:\n            raise TypeError(f\"Invalid arguments to create {comp_type}: {e}\")\n\n        if comp_type == Method:\n            if not comp_method:\n                raise ValueError(\"Method not specified for starting method\")\n\n            # Create injected method and set it as attribute\n            injected = InjectedMethod(self, comp_method)\n            setattr(self, comp.name, injected)\n\n            # Add to document context if flag is set\n            if starting_component.document:\n                self.state[\"document\"].methods_list.append(comp.id)\n\n        elif comp_type == Signal and starting_component.document:\n            self.state[\"document\"].signals_list.append(comp.id)\n\n    logging.debug(f\"Server initialized with objects: {self.state}\")\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.broadcast","title":"broadcast","text":"<pre><code>broadcast(message)\n</code></pre> <p>Broadcast message to all connected clients</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>[tuple]</code> <p>fully constructed message in form (tag/id, contents)</p> required Source code in <code>rigatoni/core.py</code> <pre><code>def broadcast(self, message: list):\n\"\"\"Broadcast message to all connected clients\n\n    Args:\n        message [tuple]: fully constructed message in form (tag/id, contents)\n    \"\"\"\n\n    # Log message in json file if applicable\n    if self.json_output:\n        self._log_json(message)\n\n    logging.debug(f\"Broadcasting Message: ID's {message[::2]}\")\n    encoded = dumps(message)\n    websockets.broadcast(self.clients, encoded)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_buffer","title":"create_buffer","text":"<pre><code>create_buffer(name=None, size=None, inline_bytes=None, uri_bytes=None)\n</code></pre> <p>Add a Buffer object for the session. Will use a custom delegate if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the buffer, defaults to \"No-Name</p> <code>None</code> <code>size</code> <code>int</code> <p>size of the buffer in bytes</p> <code>None</code> <code>inline_bytes</code> <code>bytes</code> <p>bytes for the buffer</p> <code>None</code> <code>uri_bytes</code> <code>str</code> <p>uri to get the bytes from the web</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Buffer</code> <code>Buffer</code> <p>buffer delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_buffer(self, name: Optional[str] = None,\n                  size: int = None,\n                  inline_bytes: bytes = None,\n                  uri_bytes: str = None) -&gt; Buffer:\n\"\"\"Add a Buffer object for the session. Will use a custom delegate if applicable.\n\n    Args:\n        name (str, optional): name of the buffer, defaults to \"No-Name\n        size (int, optional): size of the buffer in bytes\n        inline_bytes (bytes, optional): bytes for the buffer\n        uri_bytes (str, optional): uri to get the bytes from the web\n\n    Returns:\n        Buffer: buffer delegate that was created\n    \"\"\"\n    return self.create_component(Buffer, name=name, size=size, inline_bytes=inline_bytes, uri_bytes=uri_bytes)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_bufferview","title":"create_bufferview","text":"<pre><code>create_bufferview(source_buffer, offset, length, name=None, type='UNK')\n</code></pre> <p>Add a BufferView object to the session. Will use a custom delegate if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>source_buffer</code> <code>BufferID</code> <p>buffer that the view is based on</p> required <code>offset</code> <code>int</code> <p>offset in bytes from the start of the buffer</p> required <code>length</code> <code>int</code> <p>length of the view in bytes</p> required <code>name</code> <code>str</code> <p>name of the buffer view</p> <code>None</code> <code>type</code> <code>str</code> <p>type of the buffer view</p> <code>'UNK'</code> <p>Returns:</p> Name Type Description <code>BufferView</code> <code>BufferView</code> <p>buffer view delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_bufferview(self,\n                      source_buffer: BufferID,\n                      offset: int,\n                      length: int,\n                      name: Optional[str] = None,\n                      type: Literal[\"UNK\", \"GEOMETRY\", \"IMAGE\"] = \"UNK\") -&gt; BufferView:\n\"\"\"Add a BufferView object to the session. Will use a custom delegate if applicable.\n\n    Args:\n        source_buffer (BufferID): buffer that the view is based on\n        offset (int): offset in bytes from the start of the buffer\n        length (int): length of the view in bytes\n        name (str, optional): name of the buffer view\n        type (str, optional): type of the buffer view\n\n    Returns:\n        BufferView: buffer view delegate that was created\n    \"\"\"\n    return self.create_component(BufferView, name=name, source_buffer=source_buffer,\n                                 offset=offset, length=length, type=type)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_component","title":"create_component","text":"<pre><code>create_component(comp_type, **kwargs)\n</code></pre> <p>Officially create new component in state</p> <p>This method updates state, updates references, and broadcasts msg to clients. It also handles the acquisition of a valid ID. This is a general creator method, but more specific versions exist for each component type. Keyword arguments should be used for specifying the attributes of the component. Any deviation from the spec will raise a validation exception.</p> <p>Note</p> <p>Since this method handles the ID, it should not be specified as one of the keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>comp_type</code> <code>Component Type</code> <p>type of component to be created</p> required <code>**kwargs</code> <p>the user should specify the attributes of the component using  keyword arguments. Refer to the noodle objects to see which attributes are required and optional. Any deviation from the spec will raise a  validation exception.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Delegate</code> <code>T</code> <p>delegate for the newly created component</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the user specifies an invalid attribute for the component</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_component(self, comp_type: Type[T], **kwargs) -&gt; T:\n\"\"\"Officially create new component in state\n\n    This method updates state, updates references, and broadcasts msg to clients.\n    It also handles the acquisition of a valid ID. This is a general creator method, but\n    more specific versions exist for each component type. Keyword arguments should be\n    used for specifying the attributes of the component. Any deviation from the spec will\n    raise a validation exception.\n\n    !!! note\n\n        Since this method handles the ID, it should not be specified as one of the keyword arguments.\n\n    Args:\n        comp_type (Component Type): type of component to be created\n        **kwargs: the user should specify the attributes of the component using \n            keyword arguments. Refer to the noodle objects to see which attributes\n            are required and optional. Any deviation from the spec will raise a \n            validation exception.\n\n    Returns:\n        Delegate: delegate for the newly created component\n\n    Raises:\n        ValueError: if the user specifies an invalid attribute for the component\n    \"\"\"\n\n    # Get ID and try to create delegate from args\n    comp_type = self.custom_delegates.get(comp_type, comp_type)\n    comp_id = self._get_id(comp_type)\n    try:\n        new_delegate = comp_type(server=self, id=comp_id, **kwargs)\n    except Exception as e:\n        raise ValueError(f\"Args: {kwargs}, invalid for initializing a {comp_type}: {e}\")\n\n    # Update state and keep track of initial version for changes / update messages\n    self.state[comp_id] = new_delegate\n    self.client_state[comp_id] = new_delegate.model_copy()\n\n    # Update references for each component referenced by this one\n    self._update_references(new_delegate, new_delegate)\n\n    # Create message and broadcast\n    message = self._prepare_message(\"create\", new_delegate)\n    self.broadcast(message)\n\n    # Return component or delegate instance if applicable\n    return new_delegate\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_entity","title":"create_entity","text":"<pre><code>create_entity(name, parent=None, transform=None, text_rep=None, web_rep=None, render_rep=None, lights=None, tables=None, plots=None, tags=None, methods_list=None, signals_list=None, influence=None)\n</code></pre> <p>Add an Entity object to the session. Will use a custom delegate if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the entity</p> required <code>parent</code> <code>EntityID</code> <p>parent entity</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>transform for the entity</p> <code>None</code> <code>text_rep</code> <code>TextRepresentation</code> <p>text representation for the entity</p> <code>None</code> <code>web_rep</code> <code>WebRepresentation</code> <p>web representation for the entity</p> <code>None</code> <code>render_rep</code> <code>RenderRepresentation</code> <p>render representation that links to geometry info</p> <code>None</code> <code>lights</code> <code>list[LightID]</code> <p>list of attached lights</p> <code>None</code> <code>tables</code> <code>list[TableID]</code> <p>list of attached tables</p> <code>None</code> <code>plots</code> <code>list[PlotID]</code> <p>list of attached plots</p> <code>None</code> <code>tags</code> <code>list[str]</code> <p>list of applicable tags</p> <code>None</code> <code>methods_list</code> <code>list[MethodID]</code> <p>list of methods attached to the entity</p> <code>None</code> <code>signals_list</code> <code>list[SignalID]</code> <p>list of signals attached to the entity</p> <code>None</code> <code>influence</code> <code>BoundingBox</code> <p>bounding box for the entity</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Entity</code> <code>Entity</code> <p>entity delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_entity(self, name: Optional[str],\n                  parent: Optional[EntityID] = None,\n                  transform: Optional[Mat4] = None,\n                  text_rep: Optional[TextRepresentation] = None,\n                  web_rep: Optional[WebRepresentation] = None,\n                  render_rep: Optional[RenderRepresentation] = None,\n                  lights: Optional[list[LightID]] = None,\n                  tables: Optional[list[TableID]] = None,\n                  plots: Optional[list[PlotID]] = None,\n                  tags: Optional[list[str]] = None,\n                  methods_list: Optional[list[MethodID]] = None,\n                  signals_list: Optional[list[SignalID]] = None,\n                  influence: Optional[BoundingBox] = None) -&gt; Entity:\n\"\"\"Add an Entity object to the session. Will use a custom delegate if applicable.\n\n    Args:\n        name (str): name of the entity\n        parent (EntityID, optional): parent entity\n        transform (Mat4, optional): transform for the entity\n        text_rep (TextRepresentation, optional): text representation for the entity\n        web_rep (WebRepresentation, optional): web representation for the entity\n        render_rep (RenderRepresentation, optional): render representation that links to geometry info\n        lights (list[LightID], optional): list of attached lights\n        tables (list[TableID], optional): list of attached tables\n        plots (list[PlotID], optional): list of attached plots\n        tags (list[str], optional): list of applicable tags\n        methods_list (list[MethodID], optional): list of methods attached to the entity\n        signals_list (list[SignalID], optional): list of signals attached to the entity\n        influence (BoundingBox, optional): bounding box for the entity\n\n    Returns:\n        Entity: entity delegate that was created\n    \"\"\"\n    return self.create_component(Entity, name=name, parent=parent, transform=transform, text_rep=text_rep,\n                                 web_rep=web_rep, render_rep=render_rep, lights=lights, tables=tables, plots=plots,\n                                 tags=tags, methods_list=methods_list, signals_list=signals_list,\n                                 influence=influence)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_geometry","title":"create_geometry","text":"<pre><code>create_geometry(patches, name=None)\n</code></pre> <p>Add a Geometry object to the session. Will use a custom delegate if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>patches</code> <code>list[GeometryPatch]</code> <p>list of geometry patches</p> required <code>name</code> <code>str</code> <p>name of the geometry</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Geometry</code> <code>Geometry</code> <p>geometry delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_geometry(self, patches: list[GeometryPatch], name: Optional[str] = None) -&gt; Geometry:\n\"\"\"Add a Geometry object to the session. Will use a custom delegate if applicable.\n\n    Args:\n        patches (list[GeometryPatch]): list of geometry patches\n        name (str, optional): name of the geometry\n\n    Returns:\n        Geometry: geometry delegate that was created\n    \"\"\"\n    return self.create_component(Geometry, name=name, patches=patches)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_image","title":"create_image","text":"<pre><code>create_image(name=None, buffer_source=None, uri_source=None)\n</code></pre> <p>Add an Image object to the session.</p> <p>Will use a custom delegate if applicable. Must specify either a buffer_source or a uri_source.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the image</p> <code>None</code> <code>buffer_source</code> <code>BufferID</code> <p>buffer data that for image</p> <code>None</code> <code>uri_source</code> <code>str</code> <p>uri to get the image bytes from</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>image delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_image(self, name: Optional[str] = None,\n                 buffer_source: BufferID = None,\n                 uri_source: str = None) -&gt; Image:\n\"\"\"Add an Image object to the session.\n\n    Will use a custom delegate if applicable. Must specify either a buffer_source or a uri_source.\n\n    Args:\n        name (str, optional): name of the image\n        buffer_source (BufferID, optional): buffer data that for image\n        uri_source (str, optional): uri to get the image bytes from\n\n    Returns:\n        Image: image delegate that was created\n    \"\"\"\n    return self.create_component(Image, name=name, buffer_source=buffer_source, uri_source=uri_source)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_light","title":"create_light","text":"<pre><code>create_light(name=None, color=(1.0, 1.0, 1.0), intensity=1.0, point=None, spot=None, directional=None)\n</code></pre> <p>Add a Light object to the session. Will use a custom delegate if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the light</p> <code>None</code> <code>color</code> <code>RGB</code> <p>color of the light</p> <code>(1.0, 1.0, 1.0)</code> <code>intensity</code> <code>float</code> <p>intensity of the light on scale from 0-1</p> <code>1.0</code> <code>point</code> <code>PointLight</code> <p>point light information</p> <code>None</code> <code>spot</code> <code>SpotLight</code> <p>spot light information</p> <code>None</code> <code>directional</code> <code>DirectionalLight</code> <p>directional light information</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Light</code> <code>Light</code> <p>light delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_light(self, name: Optional[str] = None,\n                 color: Optional[RGB] = (1.0, 1.0, 1.0),\n                 intensity: Optional[float] = 1.0,\n                 point: PointLight = None,\n                 spot: SpotLight = None,\n                 directional: DirectionalLight = None) -&gt; Light:\n\"\"\"Add a Light object to the session. Will use a custom delegate if applicable.\n\n    Args:\n        name (str, optional): name of the light\n        color (RGB, optional): color of the light\n        intensity (float, optional): intensity of the light on scale from 0-1\n        point (PointLight, optional): point light information\n        spot (SpotLight, optional): spot light information\n        directional (DirectionalLight, optional): directional light information\n\n    Returns:\n        Light: light delegate that was created\n    \"\"\"\n    return self.create_component(Light, name=name, color=color, intensity=intensity,\n                                 point=point, spot=spot, directional=directional)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_material","title":"create_material","text":"<pre><code>create_material(name=None, pbr_info=PBRInfo(), normal_texture=None, occlusion_texture=None, occlusion_texture_factor=1.0, emissive_texture=None, emissive_factor=(1.0, 1.0, 1.0), use_alpha=False, alpha_cutoff=0.5, double_sided=False)\n</code></pre> <p>Add a Material object to the session. Will use a custom delegate if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the material</p> <code>None</code> <code>pbr_info</code> <code>PBRInfo</code> <p>physically based rendering information</p> <code>PBRInfo()</code> <code>normal_texture</code> <code>TextureRef</code> <p>texture for normal mapping</p> <code>None</code> <code>occlusion_texture</code> <code>TextureRef</code> <p>texture for occlusion mapping</p> <code>None</code> <code>occlusion_texture_factor</code> <code>float</code> <p>factor for occlusion mapping</p> <code>1.0</code> <code>emissive_texture</code> <code>TextureRef</code> <p>texture for emissive mapping</p> <code>None</code> <code>emissive_factor</code> <code>Vec3</code> <p>factor for emissive mapping</p> <code>(1.0, 1.0, 1.0)</code> <code>use_alpha</code> <code>bool</code> <p>whether to use alpha</p> <code>False</code> <code>alpha_cutoff</code> <code>float</code> <p>alpha cutoff value</p> <code>0.5</code> <code>double_sided</code> <code>bool</code> <p>whether the material is double-sided</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Material</code> <code>Material</code> <p>material delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_material(self, name: Optional[str] = None,\n                    pbr_info: Optional[PBRInfo] = PBRInfo(),\n                    normal_texture: Optional[TextureRef] = None,\n                    occlusion_texture: Optional[TextureRef] = None,\n                    occlusion_texture_factor: Optional[float] = 1.0,\n                    emissive_texture: Optional[TextureRef] = None,\n                    emissive_factor: Optional[Vec3] = (1.0, 1.0, 1.0),\n                    use_alpha: Optional[bool] = False,\n                    alpha_cutoff: Optional[float] = .5,\n                    double_sided: Optional[bool] = False) -&gt; Material:\n\"\"\"Add a Material object to the session. Will use a custom delegate if applicable.\n\n    Args:\n        name (str, optional): name of the material\n        pbr_info (PBRInfo, optional): physically based rendering information\n        normal_texture (TextureRef, optional): texture for normal mapping\n        occlusion_texture (TextureRef, optional): texture for occlusion mapping\n        occlusion_texture_factor (float, optional): factor for occlusion mapping\n        emissive_texture (TextureRef, optional): texture for emissive mapping\n        emissive_factor (Vec3, optional): factor for emissive mapping\n        use_alpha (bool, optional): whether to use alpha\n        alpha_cutoff (float, optional): alpha cutoff value\n        double_sided (bool, optional): whether the material is double-sided\n\n    Returns:\n        Material: material delegate that was created\n    \"\"\"\n    return self.create_component(Material, name=name, pbr_info=pbr_info, normal_texture=normal_texture,\n                                 occlusion_texture=occlusion_texture,\n                                 occlusion_texture_factor=occlusion_texture_factor,\n                                 emissive_texture=emissive_texture, emissive_factor=emissive_factor,\n                                 use_alpha=use_alpha, alpha_cutoff=alpha_cutoff, double_sided=double_sided)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_method","title":"create_method","text":"<pre><code>create_method(name, arg_doc, doc=None, return_doc=None)\n</code></pre> <p>Add a Method object to the scene and return it. Will use a custom delegate if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the method</p> required <code>arg_doc</code> <code>list[MethodArg]</code> <p>list of arguments and documentation for the method</p> required <code>doc</code> <code>str</code> <p>documentation for the method</p> <code>None</code> <code>return_doc</code> <code>str</code> <p>documentation for the return value</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Method</code> <code>Method</code> <p>method delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_method(self, name: str,\n                  arg_doc: list[MethodArg],\n                  doc: Optional[str] = None,\n                  return_doc: Optional[str] = None) -&gt; Method:\n\"\"\"Add a Method object to the scene and return it. Will use a custom delegate if applicable.\n\n    Args:\n        name (str): name of the method\n        arg_doc (list[MethodArg]): list of arguments and documentation for the method\n        doc (str, optional): documentation for the method\n        return_doc (str, optional): documentation for the return value\n\n    Returns:\n        Method: method delegate that was created\n    \"\"\"\n    return self.create_component(Method, name=name, doc=doc, return_doc=return_doc, arg_doc=arg_doc)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_plot","title":"create_plot","text":"<pre><code>create_plot(name=None, table=None, simple_plot=None, url_plot=None, methods_list=None, signals_list=None)\n</code></pre> <p>Add a Plot object to the session. Will use a custom delegate if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the plot</p> <code>None</code> <code>table</code> <code>TableID</code> <p>table to be plotted</p> <code>None</code> <code>simple_plot</code> <code>str</code> <p>simple plot to be plotted</p> <code>None</code> <code>url_plot</code> <code>str</code> <p>url for the plot</p> <code>None</code> <code>methods_list</code> <code>list[MethodID]</code> <p>attached methods</p> <code>None</code> <code>signals_list</code> <code>list[SignalID]</code> <p>attached signals</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Plot</code> <code>Plot</code> <p>plot delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_plot(self, name: Optional[str] = None,\n                table: Optional[TableID] = None,\n                simple_plot: Optional[str] = None,\n                url_plot: Optional[str] = None,\n                methods_list: Optional[list[MethodID]] = None,\n                signals_list: Optional[list[SignalID]] = None) -&gt; Plot:\n\"\"\"Add a Plot object to the session. Will use a custom delegate if applicable.\n\n    Args:\n        name (str, optional): name of the plot\n        table (TableID, optional): table to be plotted\n        simple_plot (str, optional): simple plot to be plotted\n        url_plot (str, optional): url for the plot\n        methods_list (list[MethodID], optional): attached methods\n        signals_list (list[SignalID], optional): attached signals\n\n    Returns:\n        Plot: plot delegate that was created\n    \"\"\"\n    return self.create_component(Plot, name=name, table=table, simple_plot=simple_plot, url_plot=url_plot,\n                                 methods_list=methods_list, signals_list=signals_list)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_sampler","title":"create_sampler","text":"<pre><code>create_sampler(name=None, mag_filter='LINEAR', min_filter='LINEAR_MIPMAP_LINEAR', wrap_s='REPEAT', wrap_t='REPEAT')\n</code></pre> <p>Add a Sampler object to the session. Will use a custom delegate if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the sampler</p> <code>None</code> <code>mag_filter</code> <code>str</code> <p>magnification filter</p> <code>'LINEAR'</code> <code>min_filter</code> <code>str</code> <p>minification filter</p> <code>'LINEAR_MIPMAP_LINEAR'</code> <code>wrap_s</code> <code>str</code> <p>wrap mode for s coordinate</p> <code>'REPEAT'</code> <code>wrap_t</code> <code>str</code> <p>wrap mode for t coordinate</p> <code>'REPEAT'</code> <p>Returns:</p> Name Type Description <code>Sampler</code> <code>Sampler</code> <p>sampler delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_sampler(self, name: Optional[str] = None,\n                   mag_filter: Optional[Literal[\"NEAREST\", \"LINEAR\"]] = \"LINEAR\",\n                   min_filter: Optional[\n                       Literal[\"NEAREST\", \"LINEAR\", \"LINEAR_MIPMAP_LINEAR\"]] = \"LINEAR_MIPMAP_LINEAR\",\n                   wrap_s: Optional[SamplerMode] = \"REPEAT\",\n                   wrap_t: Optional[SamplerMode] = \"REPEAT\") -&gt; Sampler:\n\"\"\"Add a Sampler object to the session. Will use a custom delegate if applicable.\n\n    Args:\n        name (str, optional): name of the sampler\n        mag_filter (str, optional): magnification filter\n        min_filter (str, optional): minification filter\n        wrap_s (str, optional): wrap mode for s coordinate\n        wrap_t (str, optional): wrap mode for t coordinate\n\n    Returns:\n        Sampler: sampler delegate that was created\n    \"\"\"\n    return self.create_component(Sampler, name=name, mag_filter=mag_filter, min_filter=min_filter,\n                                 wrap_s=wrap_s, wrap_t=wrap_t)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_signal","title":"create_signal","text":"<pre><code>create_signal(name, doc=None, arg_doc=None)\n</code></pre> <p>Add a Signal object to the session. Will use a custom delegate if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the signal</p> required <code>doc</code> <code>str</code> <p>documentation for the signal</p> <code>None</code> <code>arg_doc</code> <code>list[MethodArg]</code> <p>list of arguments and documentation for the signal</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Signal</code> <code>Signal</code> <p>signal delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_signal(self, name: str,\n                  doc: Optional[str] = None,\n                  arg_doc: list[MethodArg] = None) -&gt; Signal:\n\"\"\"Add a Signal object to the session. Will use a custom delegate if applicable.\n\n    Args:\n        name (str): name of the signal\n        doc (str, optional): documentation for the signal\n        arg_doc (list[MethodArg], optional): list of arguments and documentation for the signal\n\n    Returns:\n        Signal: signal delegate that was created\n    \"\"\"\n    if arg_doc is None:\n        arg_doc = []\n    return self.create_component(Signal, name=name, doc=doc, arg_doc=arg_doc)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_table","title":"create_table","text":"<pre><code>create_table(name=None, meta=None, methods_list=None, signals_list=None)\n</code></pre> <p>Add a Table object to the session. Will use a custom delegate if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the table</p> <code>None</code> <code>meta</code> <code>str</code> <p>meta description for the table</p> <code>None</code> <code>methods_list</code> <code>list[MethodID]</code> <p>list of methods for the table</p> <code>None</code> <code>signals_list</code> <code>list[SignalID]</code> <p>list of signals for the table</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>table delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_table(self, name: Optional[str] = None,\n                 meta: Optional[str] = None,\n                 methods_list: Optional[list[MethodID]] = None,\n                 signals_list: Optional[list[SignalID]] = None) -&gt; Table:\n\"\"\"Add a Table object to the session. Will use a custom delegate if applicable.\n\n    Args:\n        name (str, optional): name of the table\n        meta (str, optional): meta description for the table\n        methods_list (list[MethodID], optional): list of methods for the table\n        signals_list (list[SignalID], optional): list of signals for the table\n\n    Returns:\n        Table: table delegate that was created\n    \"\"\"\n    return self.create_component(Table, name=name, meta=meta, methods_list=methods_list, signals_list=signals_list)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.create_texture","title":"create_texture","text":"<pre><code>create_texture(image, name=None, sampler=None)\n</code></pre> <p>Add a Texture object to the session. Will use a custom delegate if applicable.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ImageID</code> <p>image to be used for the texture</p> required <code>name</code> <code>str</code> <p>name of the texture</p> <code>None</code> <code>sampler</code> <code>SamplerID</code> <p>sampler to be used for the texture</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Texture</code> <code>Texture</code> <p>texture delegate that was created</p> Source code in <code>rigatoni/core.py</code> <pre><code>def create_texture(self, image: ImageID,\n                   name: Optional[str] = None,\n                   sampler: Optional[SamplerID] = None) -&gt; Texture:\n\"\"\"Add a Texture object to the session. Will use a custom delegate if applicable.\n\n    Args:\n        image (ImageID): image to be used for the texture\n        name (str, optional): name of the texture\n        sampler (SamplerID, optional): sampler to be used for the texture\n\n    Returns:\n        Texture: texture delegate that was created\n    \"\"\"\n    return self.create_component(Texture, name=name, image=image, sampler=sampler)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.delete_component","title":"delete_component","text":"<pre><code>delete_component(delegate, recursive=False)\n</code></pre> <p>Delete object in state and update clients</p> <p>This method excepts a delegate, or component ID, and will attempt to delete the component as long as it is not referenced by any other component. If this component is still being used by another, it will be added to a queue so that it can be deleted later once that reference is no longer being used. If recursive flag is set, then all components referenced by this one will also be deleted or at least queued to be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>delegate</code> <code>Component | Delegate | ID</code> <p>component / delegate to be deleted</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if the user specifies an invalid input type</p> Source code in <code>rigatoni/core.py</code> <pre><code>def delete_component(self, delegate: Union[Delegate, ID], recursive: bool = False):\n\"\"\"Delete object in state and update clients\n\n    This method excepts a delegate, or component ID, and will attempt\n    to delete the component as long as it is not referenced by any other component.\n    If this component is still being used by another, it will be added to a queue so that\n    it can be deleted later once that reference is no longer being used. If recursive flag\n    is set, then all components referenced by this one will also be deleted or at least\n    queued to be deleted.\n\n    Args:\n        delegate (Component | Delegate | ID): component / delegate to be deleted\n\n    Raises:\n        TypeError: if the user specifies an invalid input type\n    \"\"\"\n\n    # Handle cases so can except different input types - cast to ID\n    if isinstance(delegate, Delegate):\n        delegate = delegate\n        del_id = delegate.id\n    elif isinstance(delegate, ID):\n        delegate = self.state[delegate]\n        del_id = delegate.id\n    else:\n        raise TypeError(f\"Invalid type for delegate when deleting: {type(delegate)}\")\n\n    # Delete all referenced components if recursive flag is set\n    if recursive:\n        referenced = self._get_referenced(delegate)\n        for ref in referenced:\n            self.delete_component(ref, recursive=recursive)\n\n    # Delete if no references, or else queue it up for later\n    if not self.references.get(del_id):\n        self.broadcast(self._prepare_message(\"delete\", delegate))\n        del self.state[del_id]\n        del self.client_state[del_id]\n\n        # Free up the ID\n        self.ids[type(delegate)].on_deck.put(del_id)\n\n        # Clean out references from this object\n        for refs in self.references.values():\n            while del_id in refs:\n                refs.remove(del_id)\n\n        # Check if anything in the queue is now clear to be deleted\n        for comp_id in list(self.delete_queue):\n            if not self.references.get(comp_id):\n                self.delete_queue.remove(comp_id)\n                self.delete_component(comp_id)\n\n    else:\n        logging.info(f\"Couldn't delete {delegate}, referenced by {self.references[del_id]}, added to queue\")\n        self.delete_queue.add(del_id)\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.get_delegate","title":"get_delegate","text":"<pre><code>get_delegate(identifier)\n</code></pre> <p>Access components in state</p> <p>Can be called with an ID, name, or context of the delegate</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>ID | str| Dict[str, ID]]</code> <p>identifier for component</p> required <p>Returns:</p> Name Type Description <code>delegate</code> <code>Delegate</code> <p>delegate with specified identifier</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if identifier is not of type ID, str, or dict</p> <code>ValueError</code> <p>if no component with specified identifier is found or context is invalid</p> Source code in <code>rigatoni/core.py</code> <pre><code>def get_delegate(self, identifier: Union[ID, str, Dict[str, ID]]):\n\"\"\"Access components in state\n\n    Can be called with an ID, name, or context of the delegate\n\n    Args:\n        identifier (ID | str| Dict[str, ID]]): identifier for component\n\n    Returns:\n        delegate (Delegate): delegate with specified identifier\n\n    Raises:\n        TypeError: if identifier is not of type ID, str, or dict\n        ValueError: if no component with specified identifier is found or context is invalid\n    \"\"\"\n    if isinstance(identifier, ID):\n        return self.state[identifier]\n    elif isinstance(identifier, str):\n        return self.state[self.get_delegate_id(identifier)]\n    elif isinstance(identifier, dict):\n        return self.get_delegate_by_context(identifier)\n    else:\n        raise TypeError(f\"Invalid type for identifier: {type(identifier)}\")\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.get_delegate_by_context","title":"get_delegate_by_context","text":"<pre><code>get_delegate_by_context(context)\n</code></pre> <p>Get a component using a context object</p> <p>This is especially useful in methods that are invoked in a certain context.</p> <p>Note</p> <p>Contexts are only used when working with entities, tables, and plots.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>context of the form {str: ID}</p> required <p>Returns:</p> Name Type Description <code>delegate</code> <code>Delegate</code> <p>delegate from specified context</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if context is invalid</p> Source code in <code>rigatoni/core.py</code> <pre><code>def get_delegate_by_context(self, context: dict):\n\"\"\"Get a component using a context object\n\n    This is especially useful in methods that are invoked in a certain context.\n\n    !!! note\n\n        Contexts are only used when working with entities, tables, and plots.\n\n    Args:\n        context (dict): context of the form {str: ID}\n\n    Returns:\n        delegate (Delegate): delegate from specified context\n\n    Raises:\n        ValueError: if context is invalid\n    \"\"\"\n\n    entity = context.get(\"entity\")\n    table = context.get(\"table\")\n    plot = context.get(\"plot\")\n    if entity:\n        return self.get_delegate(EntityID(*entity))\n    elif table:\n        return self.get_delegate(TableID(*table))\n    elif plot:\n        return self.get_delegate(PlotID(*plot))\n    else:\n        raise ValueError(f\"Invalid context: {context}\")\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.get_delegate_id","title":"get_delegate_id","text":"<pre><code>get_delegate_id(name)\n</code></pre> <p>Get a component by using its name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of component to get</p> required <p>Returns:</p> Name Type Description <code>id</code> <code>ID</code> <p>id of component with specified name</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if no component with specified name is found</p> Source code in <code>rigatoni/core.py</code> <pre><code>def get_delegate_id(self, name: str):\n\"\"\"Get a component by using its name\n\n    Args:\n        name (str): name of component to get\n\n    Returns:\n        id (ID): id of component with specified name\n\n    Raises:\n        ValueError: if no component with specified name is found\n    \"\"\"\n\n    for delegate in self.state.values():\n        if delegate.name == name:\n            return delegate.id\n    raise ValueError(\"No Component Found\")\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.get_ids_by_type","title":"get_ids_by_type","text":"<pre><code>get_ids_by_type(component)\n</code></pre> <p>Get all ids for certain component type</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>type</code> <p>type of component to get ID's for</p> required <p>Returns:</p> Name Type Description <code>ids</code> <code>list</code> <p>list of ids for components of specified type</p> Source code in <code>rigatoni/core.py</code> <pre><code>def get_ids_by_type(self, component: Type[Delegate]) -&gt; list:\n\"\"\"Get all ids for certain component type\n\n    Args:\n        component (type): type of component to get ID's for\n\n    Returns:\n        ids: list of ids for components of specified type\n    \"\"\"\n\n    return [key for key, val in self.state.items() if isinstance(val, component)]\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.invoke_signal","title":"invoke_signal","text":"<pre><code>invoke_signal(signal, on_component, signal_data=None)\n</code></pre> <p>Send signal to target component</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>SignalID | Signal</code> <p>signal to be invoked</p> required <code>on_component</code> <code>Delegate</code> <p>component to receive the signal</p> required <code>signal_data</code> <code>dict</code> <p>data to be sent with the signal</p> <code>None</code> <p>Returns:</p> Name Type Description <code>message</code> <code>list</code> <p>message to be broadcast</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the user specifies an invalid on_component type</p> Source code in <code>rigatoni/core.py</code> <pre><code>def invoke_signal(self, signal: Union[SignalID, Signal], on_component: Delegate, signal_data: list = None):\n\"\"\"Send signal to target component\n\n    Args:\n        signal (SignalID | Signal): signal to be invoked\n        on_component (Delegate): component to receive the signal\n        signal_data (dict): data to be sent with the signal\n\n    Returns:\n        message (list): message to be broadcast\n\n    Raises:\n        ValueError: if the user specifies an invalid on_component type\n    \"\"\"\n\n    # Cast signal to ID if needed\n    if isinstance(signal, Signal):\n        signal = signal.id\n\n    # Fill in default signal data if not specified\n    if signal_data is None:\n        signal_data = []\n\n    # Get context from on_component\n    if isinstance(on_component, Entity):\n        context = InvokeIDType(entity=on_component.id)\n    elif isinstance(on_component, Table):\n        context = InvokeIDType(table=on_component.id)\n    elif isinstance(on_component, Plot):\n        context = InvokeIDType(plot=on_component.id)\n    else:\n        raise ValueError(f\"Invalid on_component type: {type(on_component)}\")\n\n    # Create invoke object and broadcast message\n    invoke = Invoke(id=signal, context=context, signal_data=signal_data)\n    message = self._prepare_message(\"invoke\", invoke)\n    self.broadcast(message)\n    return message\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Run the server</p> <p>This will run indefinitely until the server is shutdown</p> Source code in <code>rigatoni/core.py</code> <pre><code>def run(self):\n\"\"\"Run the server\n\n    This will run indefinitely until the server is shutdown\"\"\"\n    return asyncio.run(self._start_server())\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.shutdown","title":"shutdown","text":"<pre><code>shutdown()\n</code></pre> <p>Shuts down the server and closes off communication with clients</p> Source code in <code>rigatoni/core.py</code> <pre><code>def shutdown(self):\n\"\"\"Shuts down the server and closes off communication with clients\"\"\"\n    logging.info(\"Shutting down server...\")\n    self.shutdown_event.set()\n</code></pre>"},{"location":"api_reference/server/#rigatoni.Server.update_component","title":"update_component","text":"<pre><code>update_component(current)\n</code></pre> <p>Update clients with changes to a component</p> <p>This method broadcasts changes to all clients including only fields specified in the set delta. Local changes to delegates will be saved in the server's state, but this method must be called to update clients.</p> <p>Parameters:</p> Name Type Description Default <code>current</code> <code>Delegate</code> <p>component that has been updated, should be a component with an update message</p> required Source code in <code>rigatoni/core.py</code> <pre><code>def update_component(self, current: Delegate):\n\"\"\"Update clients with changes to a component\n\n    This method broadcasts changes to all clients including only fields\n    specified in the set delta. Local changes to delegates will be saved\n    in the server's state, but this method must be called to update clients.\n\n    Args:\n        current (Delegate): component that has been updated,\n            should be a component with an update message\n    \"\"\"\n\n    # Find difference between two states\n    outdated = self.client_state[current.id]\n    delta = self._find_delta(outdated, current)\n\n    # Update references\n    self._update_references(outdated, outdated, removing=True)\n    self._update_references(current, current)\n\n    # Update tracking state\n    self.client_state[current.id] = current.model_copy()\n\n    # Form message and broadcast\n    try:\n        message = self._prepare_message(\"update\", current, delta)\n        self.broadcast(message)\n    except Exception as e:\n        raise ValueError(f\"This obj can not be updated: {e}\")\n</code></pre>"},{"location":"api_reference/support_objects/","title":"Supporting Objects","text":"<p>These are objects that are used by other components in the library.</p>"},{"location":"api_reference/support_objects/#ids","title":"ID's","text":""},{"location":"api_reference/support_objects/#rigatoni.ID","title":"rigatoni.ID","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Base class for all ID's</p> <p>Each ID is composed of a slot and a generation, resulting in a tuple like id ex. (0, 0). Both are positive integers that are filled in increasing order. Slots are taken first, but once the slot is freed, it can be used with a new generation. For example, a method is created -&gt; (0, 0), then another is created -&gt; (1, 0), then method (0, 0) is deleted. Now, the next method created will be (0, 1).</p> <p>Attributes:</p> Name Type Description <code>slot</code> <code>int</code> <p>Slot of the ID</p> <code>gen</code> <code>int</code> <p>Generation of the ID</p>"},{"location":"api_reference/support_objects/#rigatoni.MethodID","title":"rigatoni.MethodID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for methods</p>"},{"location":"api_reference/support_objects/#rigatoni.SignalID","title":"rigatoni.SignalID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for signals</p>"},{"location":"api_reference/support_objects/#rigatoni.EntityID","title":"rigatoni.EntityID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for entities</p>"},{"location":"api_reference/support_objects/#rigatoni.PlotID","title":"rigatoni.PlotID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for plots</p>"},{"location":"api_reference/support_objects/#rigatoni.BufferID","title":"rigatoni.BufferID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for buffers</p>"},{"location":"api_reference/support_objects/#rigatoni.BufferViewID","title":"rigatoni.BufferViewID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for buffer views</p>"},{"location":"api_reference/support_objects/#rigatoni.MaterialID","title":"rigatoni.MaterialID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for materials</p>"},{"location":"api_reference/support_objects/#rigatoni.ImageID","title":"rigatoni.ImageID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for images</p>"},{"location":"api_reference/support_objects/#rigatoni.TextureID","title":"rigatoni.TextureID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for textures</p>"},{"location":"api_reference/support_objects/#rigatoni.SamplerID","title":"rigatoni.SamplerID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for samplers</p>"},{"location":"api_reference/support_objects/#rigatoni.LightID","title":"rigatoni.LightID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for lights</p>"},{"location":"api_reference/support_objects/#rigatoni.GeometryID","title":"rigatoni.GeometryID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for geometries</p>"},{"location":"api_reference/support_objects/#rigatoni.TableID","title":"rigatoni.TableID","text":"<p>             Bases: <code>ID</code></p> <p>ID specifically for tables</p>"},{"location":"api_reference/support_objects/#enums-for-specific-string-options","title":"Enums for Specific String Options","text":""},{"location":"api_reference/support_objects/#rigatoni.AttributeSemantic","title":"rigatoni.AttributeSemantic","text":"<p>             Bases: <code>Enum</code></p> <p>String indicating type of attribute, used in Attribute inside of geometry patch</p> <p>Takes value of either POSITION, NORMAL, TANGENT, TEXTURE, or COLOR</p>"},{"location":"api_reference/support_objects/#rigatoni.Format","title":"rigatoni.Format","text":"<p>             Bases: <code>Enum</code></p> <p>String indicating format of byte data for an attribute</p> <p>Used in Attribute inside of geometry patch. Takes value of either U8, U16, U32, U8VEC4, U16VEC2, VEC2, VEC3, VEC4, MAT3, or MAT4</p>"},{"location":"api_reference/support_objects/#rigatoni.IndexFormat","title":"rigatoni.IndexFormat","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>String indicating format of byte data for an index</p> <p>Used in Index inside of geometry patch. Takes value of either U8, U16, or U32</p>"},{"location":"api_reference/support_objects/#rigatoni.PrimitiveType","title":"rigatoni.PrimitiveType","text":"<p>             Bases: <code>Enum</code></p> <p>String indicating type of primitive used in a geometry patch</p> <p>Takes value of either POINTS, LINES, LINE_LOOP, LINE_STRIP, TRIANGLES, or TRIANGLE_STRIP</p>"},{"location":"api_reference/support_objects/#rigatoni.ColumnType","title":"rigatoni.ColumnType","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>String indicating type of data stored in a column in a table</p> <p>Used in TableColumnInfo inside TableInitData. Takes value of either TEXT, REAL, or INTEGER</p>"},{"location":"api_reference/support_objects/#rigatoni.BufferType","title":"rigatoni.BufferType","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>String indicating type of data stored in a buffer</p> <p>Used in BufferView. Takes value of either UNK, GEOMETRY, or IMAGE</p>"},{"location":"api_reference/support_objects/#rigatoni.SamplerMode","title":"rigatoni.SamplerMode","text":"<p>             Bases: <code>Enum</code></p> <p>String options for sampler mode</p> <p>Used in Sampler. Takes value of either CLAMP_TO_EDGE, MIRRORED_REPEAT, or REPEAT</p>"},{"location":"api_reference/support_objects/#rigatoni.MagFilterTypes","title":"rigatoni.MagFilterTypes","text":"<p>             Bases: <code>Enum</code></p> <p>Options for magnification filter type</p> <p>Used in Sampler. Takes value of either NEAREST or LINEAR</p>"},{"location":"api_reference/support_objects/#rigatoni.MinFilterTypes","title":"rigatoni.MinFilterTypes","text":"<p>             Bases: <code>Enum</code></p> <p>Options for minification filter type</p> <p>Used in Sampler. Takes value of either NEAREST, LINEAR, or LINEAR_MIPMAP_LINEAR</p>"},{"location":"api_reference/support_objects/#supporting-objects_1","title":"Supporting Objects","text":""},{"location":"api_reference/support_objects/#rigatoni.SelectionRange","title":"rigatoni.SelectionRange","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Range of rows to select in a table</p> <p>Attributes:</p> Name Type Description <code>key_from_inclusive</code> <code>int</code> <p>First row to select</p> <code>key_to_exclusive</code> <code>int</code> <p>Where to end selection, exclusive</p>"},{"location":"api_reference/support_objects/#rigatoni.Selection","title":"rigatoni.Selection","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Selection of rows in a table</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of selection</p> <code>rows</code> <code>List[int]</code> <p>List of rows to select</p> <code>row_ranges</code> <code>List[SelectionRange]</code> <p>List of ranges of rows to select</p>"},{"location":"api_reference/support_objects/#rigatoni.MethodArg","title":"rigatoni.MethodArg","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Argument for a method</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of argument</p> <code>doc</code> <code>str</code> <p>Documentation for argument</p> <code>editor_hint</code> <code>str</code> <p>Hint for editor, refer to message spec for hint options</p>"},{"location":"api_reference/support_objects/#rigatoni.BoundingBox","title":"rigatoni.BoundingBox","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Axis-aligned bounding box</p> <p>Attributes:</p> Name Type Description <code>min</code> <code>Vec3</code> <p>Minimum point of bounding box</p> <code>max</code> <code>Vec3</code> <p>Maximum point of bounding box</p>"},{"location":"api_reference/support_objects/#rigatoni.TextRepresentation","title":"rigatoni.TextRepresentation","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Text representation for an entity</p> <p>Attributes:</p> Name Type Description <code>txt</code> <code>str</code> <p>Text to display</p> <code>font</code> <code>str</code> <p>Font to use</p> <code>height</code> <code>Optional[float]</code> <p>Height of text</p> <code>width</code> <code>Optional[float]</code> <p>Width of text</p>"},{"location":"api_reference/support_objects/#rigatoni.WebRepresentation","title":"rigatoni.WebRepresentation","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Web page with a given URL rendered as a plane</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>str</code> <p>URL for entity</p> <code>height</code> <code>Optional[float]</code> <p>Height of plane</p> <code>width</code> <code>Optional[float]</code> <p>Width of plane</p>"},{"location":"api_reference/support_objects/#rigatoni.InstanceSource","title":"rigatoni.InstanceSource","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Source of instances for a geometry patch</p> <p>Attributes:</p> Name Type Description <code>view</code> <code>BufferViewID</code> <p>View of mat4</p> <code>stride</code> <code>int</code> <p>Stride for buffer, defaults to tightly packed</p> <code>bb</code> <code>BoundingBox</code> <p>Bounding box of instances</p>"},{"location":"api_reference/support_objects/#rigatoni.RenderRepresentation","title":"rigatoni.RenderRepresentation","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Render representation for an entity</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>GeometryID</code> <p>Mesh to render</p> <code>instances</code> <code>Optional[InstanceSource]</code> <p>Source of instances for mesh</p>"},{"location":"api_reference/support_objects/#rigatoni.TextureRef","title":"rigatoni.TextureRef","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Reference to a texture</p> <p>Attributes:</p> Name Type Description <code>texture</code> <code>TextureID</code> <p>Texture to reference</p> <code>transform</code> <code>Optional[Mat3]</code> <p>Transform to apply to texture</p> <code>texture_coord_slot</code> <code>Optional[int]</code> <p>Texture coordinate slot to use</p>"},{"location":"api_reference/support_objects/#rigatoni.PBRInfo","title":"rigatoni.PBRInfo","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Physically based rendering information for a material</p> <p>Attributes:</p> Name Type Description <code>base_color</code> <code>Optional[RGBA]</code> <p>Base color of material</p> <code>base_color_texture</code> <code>Optional[TextureRef]</code> <p>Texture to use for base color</p> <code>metallic</code> <code>Optional[float]</code> <p>Metallic value of material</p> <code>roughness</code> <code>Optional[float]</code> <p>Roughness value of material</p> <code>metal_rough_texture</code> <code>Optional[TextureRef]</code> <p>Texture to use for metallic and roughness</p>"},{"location":"api_reference/support_objects/#rigatoni.PointLight","title":"rigatoni.PointLight","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Point light information for a light delegate</p> <p>Attributes:</p> Name Type Description <code>range</code> <code>float</code> <p>Range of light, -1 defaults to infinite</p>"},{"location":"api_reference/support_objects/#rigatoni.SpotLight","title":"rigatoni.SpotLight","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Spotlight information for a light delegate</p> <p>Attributes:</p> Name Type Description <code>range</code> <code>float</code> <p>Range of light, -1 defaults to infinite</p> <code>inner_cone_angle_rad</code> <code>float</code> <p>Inner cone angle of light</p> <code>outer_cone_angle_rad</code> <code>float</code> <p>Outer cone angle of light</p>"},{"location":"api_reference/support_objects/#rigatoni.DirectionalLight","title":"rigatoni.DirectionalLight","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Directional light information for a light delegate</p> <p>Attributes:</p> Name Type Description <code>range</code> <code>float</code> <p>Range of light, -1 defaults to infinite</p>"},{"location":"api_reference/support_objects/#rigatoni.Attribute","title":"rigatoni.Attribute","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Attribute for a geometry patch</p> <p>Each attribute is a view into a buffer that corresponds to a specific element of the mesh (e.g. position, normal, etc.). Attributes allow information for the vertices to be extracted from buffers</p> <p>Attributes:</p> Name Type Description <code>view</code> <code>BufferViewID</code> <p>View of the buffer storing the data</p> <code>semantic</code> <code>AttributeSemantic</code> <p>String describing the type of attribute</p> <code>channel</code> <code>Optional[int]</code> <p>Channel of attribute, if applicable</p> <code>offset</code> <code>Optional[int]</code> <p>Offset into buffer</p> <code>stride</code> <code>Optional[int]</code> <p>Distance, in bytes, between data for two vertices in the buffer</p> <code>format</code> <code>Format</code> <p>How many bytes per element, how to decode the bytes</p> <code>minimum_value</code> <code>Optional[List[float]]</code> <p>Minimum value for attribute data</p> <code>maximum_value</code> <code>Optional[List[float]]</code> <p>Maximum value for attribute data</p> <code>normalized</code> <code>Optional[bool]</code> <p>Whether to normalize the attribute data</p>"},{"location":"api_reference/support_objects/#rigatoni.Index","title":"rigatoni.Index","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Index for a geometry patch</p> <p>The index is a view into a buffer that corresponds to the indices of the mesh. The index allows the mesh to connect vertices and render triangles, lines, or points.</p> <p>Attributes:</p> Name Type Description <code>view</code> <code>BufferViewID</code> <p>View of the buffer storing the data</p> <code>count</code> <code>int</code> <p>Number of indices</p> <code>offset</code> <code>Optional[int]</code> <p>Offset into buffer</p> <code>stride</code> <code>Optional[int]</code> <p>Distance, in bytes, between data for two elements in the buffer</p> <code>format</code> <code>IndexFormat</code> <p>How many bytes per element, how to decode the bytes</p>"},{"location":"api_reference/support_objects/#rigatoni.GeometryPatch","title":"rigatoni.GeometryPatch","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Geometry patch for a mesh</p> <p>Principle object used in geometry delegates. A geometry patch combines vertex data from attributes and index data from indices.</p> <p>Attributes:</p> Name Type Description <code>attributes</code> <code>List[Attribute]</code> <p>List of attributes storing vertex data for the mesh</p> <code>vertex_count</code> <code>int</code> <p>Number of vertices in the mesh</p> <code>indices</code> <code>Optional[Index]</code> <p>Indices for the mesh</p> <code>type</code> <code>PrimitiveType</code> <p>Type of primitive to render</p> <code>material</code> <code>MaterialID</code> <p>Material to use for rendering</p>"},{"location":"api_reference/support_objects/#rigatoni.InvokeIDType","title":"rigatoni.InvokeIDType","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Context for invoking a signal</p> <p>Attributes:</p> Name Type Description <code>entity</code> <code>Optional[EntityID]</code> <p>Entity to invoke signal on</p> <code>table</code> <code>Optional[TableID]</code> <p>Table to invoke signal on</p> <code>plot</code> <code>Optional[PlotID]</code> <p>Plot to invoke signal on</p>"},{"location":"api_reference/support_objects/#rigatoni.InvokeIDType.one_of_three","title":"one_of_three","text":"<pre><code>one_of_three(model)\n</code></pre> <p>Ensure only one of the three attributes is set</p> Source code in <code>rigatoni/noodle_objects.py</code> <pre><code>@model_validator(mode=\"after\")\ndef one_of_three(cls, model):\n\"\"\"Ensure only one of the three attributes is set\"\"\"\n    selected = bool(model.entity) + bool(model.table) + bool(model.plot)\n    if selected != 1:\n        raise ValueError(\"Must select exactly one of entity, table, or plot\")\n    return model\n</code></pre>"},{"location":"api_reference/support_objects/#rigatoni.TableColumnInfo","title":"rigatoni.TableColumnInfo","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Information about a column in a table</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of column</p> <code>type</code> <code>ColumnType</code> <p>Type data in the column</p>"},{"location":"api_reference/support_objects/#rigatoni.TableInitData","title":"rigatoni.TableInitData","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Init data to create a table</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>List[TableColumnInfo]</code> <p>List of column information</p> <code>keys</code> <code>List[int]</code> <p>List of column indices that are keys</p> <code>data</code> <code>List[List[Any]]</code> <p>List of rows of data</p> <code>selections</code> <code>Optional[List[Selection]]</code> <p>List of selections to apply to table</p>"}]}